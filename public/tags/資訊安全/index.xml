<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>資訊安全 on LucChang Blog</title>
        <link>http://localhost:1313/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/</link>
        <description>Recent content in 資訊安全 on LucChang Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 25 Apr 2025 09:42:57 +0800</lastBuildDate><atom:link href="http://localhost:1313/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AIS3 Junior 夏令營</title>
        <link>http://localhost:1313/post/summer-camp/</link>
        <pubDate>Fri, 25 Apr 2025 09:42:57 +0800</pubDate>
        
        <guid>http://localhost:1313/post/summer-camp/</guid>
        <description>&lt;img src="https://public-imgbed.pages.dev/file/1744726758922_Screenshot 2025-04-15 221605.png" alt="Featured image of post AIS3 Junior 夏令營" /&gt;&lt;h3 id=&#34;為什麼我要參加ais3-junior-資安營對&#34;&gt;為什麼我要參加AIS3 Junior 資安營對
&lt;/h3&gt;&lt;p&gt;在高一期間開始接觸到資安的領域，在營隊之前有些觸過pwn和crypto，但是我覺得在資安相關的領域我真的沒有見聞，於是就決定參加AIS3 Junior。在參加AIS3 Junior前兩個月就需要先頭自己的履歷給官方，因為這個營隊是教育部全額補助的活動，所以在報名的流程需要篩選合適的人選，幸運地我入選AIS3 Junior的名單😊。&lt;/p&gt;
&lt;h3 id=&#34;day1&#34;&gt;DAY1
&lt;/h3&gt;&lt;p&gt;由於AIS3 Junior 舉辦地點在嘉義的中正大學，所以我千里迢迢的從新北市奔波到嘉義，幸好集合時間在下午五點，這樣我就不需要這麼的急忙。下午到了嘉義車站後，我姑丈開車載我到中正大學(他媽的為什麼不再火車站旁邊)，因為下雨的關係所以我遲到了15分鐘。到了集合地點我突然看見了很熟悉麼面孔，原來是前一個營隊的室友黃士育，不知道甚麼機緣我們又再次變成了室友，而且組別也相同。第一天其實沒有什麼行程，剛集合完就去住宿的地方了，晚上吃完飯回到宿舍就開始Setup隔天要使用的的kali虛擬機，大概就是這樣了。&lt;/p&gt;
&lt;h3 id=&#34;day2&#34;&gt;Day2
&lt;/h3&gt;&lt;p&gt;今天課程正式開始，早上我跟室友們從宿舍走道了講廳(超遠)，到了講廳終於遇到了小組的成員包含我們的隊輔(資安大老)，接下來就進入到了第一堂課了，主要就是在講資安倫理、資安攻擊方式以及趨勢等，到了第二堂課開始進入資安概論，學到了linux系統的基本指令以及架構，也有很多lab 的題目運用linux的指令取找flag。我是第一次接觸過linux的指令，整堂課整個矇掉，看到其他學員都行雲流水的打起鍵盤，但我只表現出不失所措的樣子，幸好助教以及組員們都很助人，我才慢慢地能夠理解linux指令的用法以及lab上的題目要做什麼。&lt;/p&gt;
&lt;p&gt;下午除了破斌遊戲又有一個資安概論同樣的也是在講解linux指令以及使用方面的教學，同時也繼續上我們完成lab上的題目。晚上回到宿舍就是lab 作業時間，所以大家都忙著解題，慢慢熟練Linux 的指令後，發現題目也沒有想像中的難，其實就是考驗對於Linux 指令的熟練度。&lt;/p&gt;
&lt;h3 id=&#34;day3&#34;&gt;Day3
&lt;/h3&gt;&lt;p&gt;來到了第三天，今天的上課主題與昨天不同，要上的是Web Security(網路安全)，主題更難了一些，需要了解一些網頁的概念以及協議等，但這些東西都是之前就有接觸過的東西。Web Security 這次教到的攻擊手法有XSS, LFI, Webshell, CMDi, SQLi, SSRF以及SSTI等，這些東西我從來沒有聽過，雖然在上課時對於這些攻擊方式的原理一知半解，也不太曉得這些攻擊守法的用途以及公用，但是透過lab 著手製造這些攻擊其實也挺有趣的，也讓我對於這些攻擊至少有一些幹念，透過不同的漏洞取得RCE(遠端程式碼執行)挺有成就感的。
上午的課堂以及下午的第一堂課都在講解Web Security 相關的領域，到了下午第二堂就進入了這次的魔王主題「AI 應用安全實務」，這個主題是我認為非常有挑戰性，雖然AI釋普現現代人都用過的東西，但是運用在資安方面就是一個非常深奧的學問。在這個主題中我們先認識什麼事Transformer 模型，以及 Transformer 模型的原理，同樣的我們也認識到Prompt engineering，如何透過說話的藝術讓模型更清楚知道使用者要的東西，甚至繞過模型內部的規範，存取模型內部被禁止存取的東西。所以這幾天的lab我們一直在跟AI 助理聊天，要怎麼透過Prompt Injection的方式繞過模型內部審核機制來取得FLag，這個主題讓我心力憔悴，像是在寫作文一樣，構造不同的文具或是不同的技巧(改變attention 區間等)，讓模型繞過自己的審核機制真的超級困難，我的室友們很快就解出來了，無論我怎麼構造Prompt 最後都還是無法存取到flag，甚至花上了好幾小時的時間還是無法解開，可能我對於整個prompt 的 format 或是 Cot Prompting 的技巧還沒有這麼熟練。&lt;/p&gt;
&lt;h3 id=&#34;day-4&#34;&gt;Day 4
&lt;/h3&gt;&lt;h3 id=&#34;day-5&#34;&gt;Day 5
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>picoCTF Write up</title>
        <link>http://localhost:1313/post/picocft-writeup/writeup/</link>
        <pubDate>Tue, 28 May 2024 15:04:05 +0000</pubDate>
        
        <guid>http://localhost:1313/post/picocft-writeup/writeup/</guid>
        <description></description>
        </item>
        <item>
        <title>關於XSS的ㄋㄚˋ些事</title>
        <link>http://localhost:1313/post/about-xss/about_xss/</link>
        <pubDate>Tue, 28 May 2024 15:04:05 +0000</pubDate>
        
        <guid>http://localhost:1313/post/about-xss/about_xss/</guid>
        <description>&lt;h1 id=&#34;深入理解-cross-site-scripting-xss-攻擊與防禦&#34;&gt;深入理解 Cross-Site Scripting (XSS) 攻擊與防禦
&lt;/h1&gt;&lt;p&gt;Cross-Site Scripting (XSS)，即跨網站指令碼，是前端開發中常見且危險的資安漏洞。它的核心概念是讓攻擊者能夠在其他使用者（客戶端）的瀏覽器上執行惡意的 JavaScript 或其他指令碼，進而竊取敏感資訊、劫持使用者會話，甚至操控網頁行為。&lt;/p&gt;
&lt;p&gt;XSS 攻擊之所以發生，通常是因為網站未能妥善處理來自使用者的輸入，導致輸入的內容被瀏覽器誤認為是可執行的程式碼，而非單純的資料。常見的輸入點包括表單欄位（如搜尋框、留言區、使用者名稱）、URL 參數等。攻擊者可能會輸入類似 &lt;code&gt;&amp;lt;script&amp;gt;alert(&#39;XSS&#39;)&amp;lt;/script&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;img src onerror=&amp;quot;alert(&#39;XSS&#39;)&amp;quot;&amp;gt;&lt;/code&gt; 這樣的代碼來測試或發動攻擊。&lt;/p&gt;
&lt;p&gt;根據惡意代碼 (payload) 的來源和其在伺服器上的存儲方式，XSS 可以分為幾種類型：&lt;/p&gt;
&lt;h2 id=&#34;xss-的分類-依據-payload-的來源儲存&#34;&gt;XSS 的分類 (依據 Payload 的來源/儲存)
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reflected XSS (反射型 XSS)：&lt;/strong&gt;
這種攻擊的 payload 不會被永久儲存到伺服器的資料庫中。攻擊者通常會將惡意代碼嵌入到 URL 參數中，然後誘騙受害者點擊這個包含 payload 的惡意連結。當受害者的瀏覽器向伺服器發出請求時，伺服器未經處理地將包含 payload 的內容反射回受害者的瀏覽器，導致 payload 在受害者的瀏覽器中執行。它的生命週期短暫，只在使用者訪問帶有惡意參數的 URL 時觸發一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stored XSS (儲存型 XSS)：&lt;/strong&gt;
這種攻擊是最具破壞力的類型之一。攻擊者成功地將惡意 payload 永久地儲存到目標網站的資料庫中（例如在論壇發帖、留言或修改使用者資料時注入）。當其他使用者瀏覽包含此 payload 的網頁時，伺服器會將儲存的惡意代碼連同正常內容一起發送給客戶端瀏覽器，導致 payload 在每個訪問該頁面的使用者瀏覽器中執行。危害範圍廣，且不需要額外的使用者互動（如點擊連結）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DOM-based XSS (基於 DOM 的 XSS)：&lt;/strong&gt;
與前兩種主要依賴伺服器端處理不同，DOM-based XSS 漏洞存在於前端的 JavaScript 代碼中。惡意 payload 可能來自 URL 的片段識別符號（# 後面的部分）或其他客戶端可控的來源。前端 JavaScript 使用這些受控的資料不安全地操作文件物件模型 (DOM)，例如將資料寫入 &lt;code&gt;innerHTML&lt;/code&gt; 或使用 &lt;code&gt;eval()&lt;/code&gt; 函數，導致 payload 被瀏覽器作為程式碼執行。這種攻擊完全在客戶端進行，伺服器端可能完全不受影響。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;常見的-xss-payload-目標&#34;&gt;常見的 XSS Payload 目標
&lt;/h2&gt;&lt;p&gt;攻擊者注入惡意 JavaScript 的目的多種多樣，常見的 payload 功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Workspace()&lt;/code&gt; 或 &lt;code&gt;XMLHttpRequest&lt;/code&gt;: 將使用者的敏感資料（如 Cookies）發送到攻擊者控制的伺服器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.cookie&lt;/code&gt;: 竊取使用者的 Session Cookies，可能導致攻擊者劫持使用者會話。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html2canvas&lt;/code&gt; (或其他截圖庫): 對使用者正在瀏覽的頁面進行截圖，可能捕獲敏感視覺資訊。&lt;/li&gt;
&lt;li&gt;Keylogger: 記錄使用者在頁面上的鍵盤輸入，竊取密碼、信用卡號等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alert()&lt;/code&gt;: 最簡單的 PoC (Proof of Concept)，用於驗證 XSS 漏洞是否存在。&lt;/li&gt;
&lt;li&gt;重新導向使用者到惡意網站、修改網頁內容進行釣魚等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xss-的進階概念&#34;&gt;XSS 的進階概念
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;XSS Worm (XSS 蠕蟲)：&lt;/strong&gt;
一種更進階的 XSS 攻擊形式。惡意 JavaScript 不僅攻擊當前使用者，還會利用當前使用者的權限（如社交網路發帖權限）將 XSS payload 注入到他們能影響到的內容中，進而感染他們的聯繫人或粉絲。這導致 payload 像病毒一樣在使用者之間互相傳播，造成大規模感染。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Blind XSS (盲打型 XSS)：&lt;/strong&gt;
攻擊者注入 payload 後，不會立即看到效果，也不知道 payload 何時何地會被觸發。payload 被儲存在網站的某個位置，可能是在後台管理系統、日誌查看器、客戶服務面板等只有網站內部人員會訪問的地方。當內部人員訪問這些頁面時，payload 被執行，並通常會“打回來”通知攻擊者（例如向攻擊者發送一個包含執行環境資訊的請求）。攻擊者是「盲打」，等待 payload 在一個未知的時機和地點被「看到」。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Self-XSS (自體 XSS)：&lt;/strong&gt;
這是一種需要使用者自己手動執行惡意代碼的 XSS。通常攻擊者會欺騙使用者在瀏覽器的開發者控制台中貼上並執行一段 JavaScript 代碼。這種攻擊通常不能強加給使用者，主要依賴於社會工程學來誘導使用者自己攻擊自己，對其他使用者不構成直接威脅，但仍可能導致帳戶被盜用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xss-的防禦策略&#34;&gt;XSS 的防禦策略
&lt;/h2&gt;&lt;p&gt;防禦 XSS 是一個需要多層次方法的課題：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;輸入驗證 (Input Validation) 與輸出編碼 (Output Encoding)：&lt;/strong&gt;
這是最基本也是最重要的防禦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;輸入驗證：&lt;/strong&gt; 檢查使用者輸入的內容是否符合預期的格式和類型。例如，如果只允許數字，則拒絕包含其他字元的輸入。這有助於過濾掉明顯不符合規範的輸入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;輸出編碼/轉義 (Encoding/Escaping)：&lt;/strong&gt; 當需要在 HTML 頁面中顯示使用者輸入的內容時，必須對所有輸出進行嚴格的編碼或轉義。將具有特殊意義的 HTML 字元（如 &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;quot;&lt;/code&gt;, &lt;code&gt;&#39;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; 等）轉換為它們的 HTML 實體（如 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;amp;gt;&lt;/code&gt; 等）。這樣瀏覽器就會把這些內容當作普通文本顯示，而不會解析為 HTML 標籤或 JavaScript 代碼。這是防禦 Reflected 和 Stored XSS 的首要措施。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HTML 過濾 (HTML Sanitization)：&lt;/strong&gt;
當網站允許使用者輸入包含 HTML 標籤的富文本內容時（例如評論區的粗體、斜體格式），不能簡單地全部編碼。這時需要使用 HTML 過濾器。過濾器的作用是移除或修改輸入 HTML 中潛在的危險元素（如 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt; 標籤）和危險屬性（如 &lt;code&gt;onerror&lt;/code&gt;, &lt;code&gt;onload&lt;/code&gt;, &lt;code&gt;href&lt;/code&gt; 中的 &lt;code&gt;javascript:&lt;/code&gt; 偽協議等），只保留安全的 HTML 標籤和屬性。這是一個複雜的任務，很難手動完美處理所有情況。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DOMPurify：&lt;/strong&gt; 是一個被廣泛使用的、強健的 HTML 過濾庫，它在瀏覽器端運行，能有效淨化 HTML 片段。但即使是 DOMPurify，不正確的使用方式也可能引入漏洞，需要仔細閱讀其文檔。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;內容安全政策 (Content Security Policy, CSP)：&lt;/strong&gt;
CSP 是一種由瀏覽器強制執行的安全層。通過在 HTTP 頭部或 HTML 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 標籤中定義一系列策略，網站可以告訴瀏覽器允許從哪些來源載入哪些類型的資源（如腳本、樣式表、圖片等）。這本質上是一個白名單機制。
CSP 並不能完全阻止 XSS 注入，但它可以極大地限制被注入腳本的執行能力，例如禁止內聯腳本 (&lt;code&gt;&amp;lt;script&amp;gt;... &amp;lt;/script&amp;gt;&lt;/code&gt;)、禁止從未知來源加載外部腳本、限制表單提交的目標等。它是作為&lt;strong&gt;縱深防禦&lt;/strong&gt;的重要一環，即使其他防禦措施失效，CSP 也能降低攻擊的影響。
常見的 CSP 指令 (Directive) 包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default-src&lt;/code&gt;: 所有資源的預設策略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;script-src&lt;/code&gt;: 規定腳本的允許來源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;img-src&lt;/code&gt;: 規定圖片的允許來源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connect-src&lt;/code&gt;: 規定 XMLHttpRequest, WebSockets 等連線的允許目標。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style-src&lt;/code&gt;: 規定樣式表的允許來源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Maps-to&lt;/code&gt;: 限制頁面導航和表單提交的目標 URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;csp-的繞過-csp-bypassing&#34;&gt;CSP 的繞過 (CSP Bypassing)
&lt;/h2&gt;&lt;p&gt;儘管 CSP 提供了強大的保護，但配置不當的策略仍然可能被繞過。例如，如果 CSP 的 &lt;code&gt;script-src&lt;/code&gt; 策略允許從一個包含 JSONP 端點的域名加載腳本，攻擊者可能可以利用 JSONP 的回調機制來執行任意 JavaScript，即使網站本身沒有直接的 XSS 漏洞。這提醒我們 CSP 配置需要非常謹慎，且不能僅依賴 CSP。&lt;/p&gt;
&lt;h2 id=&#34;javascript-偽協議-javascript-pseudo-protocol&#34;&gt;JavaScript 偽協議 (javascript: pseudo-protocol)
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;javascript:&lt;/code&gt; 偽協議允許在 URL 或某些 HTML 屬性（如 &lt;code&gt;&amp;lt;a href=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;img src=&amp;quot;...&amp;quot;&amp;gt;&lt;/code&gt;）中使用 JavaScript 代碼。例如 &lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1)&amp;quot;&amp;gt;點我&amp;lt;/a&amp;gt;&lt;/code&gt;。如果不對使用者輸入的 URL 或屬性值進行驗證和過濾，攻擊者可以注入這樣的連結來觸發 JavaScript 執行，這也是 XSS 的一種表現形式。&lt;/p&gt;
&lt;h2 id=&#34;總結&#34;&gt;總結
&lt;/h2&gt;&lt;p&gt;Cross-Site Scripting (XSS) 是一個嚴重的 Web 安全問題，它可以讓攻擊者在其他使用者的瀏覽器上執行惡意程式碼。理解 Reflected, Stored, 和 DOM-based XSS 的區別對於識別和防禦漏洞至關重要。防禦 XSS 需要一個多層次的方法：優先對所有使用者輸出進行&lt;strong&gt;嚴格的編碼/轉義&lt;/strong&gt;；在允許富文本的場景下使用&lt;strong&gt;安全的 HTML 過濾庫 (如 DOMPurify)&lt;/strong&gt;；並配置&lt;strong&gt;強大的 Content Security Policy (CSP)&lt;/strong&gt; 作為最後一道防線。始終記住，對使用者輸入保持警惕，並在輸出時假設它是不可信的，是防止 XSS 的關鍵原則。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
